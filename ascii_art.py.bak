#!/usr/bin/env python3

import sys
import argparse
import curses
import math
import os

try:
    from PIL import Image
except ImportError:
    print("ERROR: Pillow (PIL) library not installed. Please install via pip:\n  pip install Pillow")
    sys.exit(1)


# ---------------------------------------------------------------------------
# 1) Some pre-defined ASCII character sets:
#    "density" from lightest to darkest, or vice versa
# ---------------------------------------------------------------------------

CHAR_SETS = [
    " .:-=+*#%@" ,               # 10 chars
    " .'`,^:\";!i~+_-?][}{1)(|\\lI<>rctvxyzuJCOAs238&%$W#@" ,  # Extended set
    "@%#*+=-:. ",                # Reverse order
    " .oO@ "                     # Very minimal
]

# ---------------------------------------------------------------------------
# 2) Some color gradients or modes:
#    - "none": no color
#    - "grayscale": approximate shade
#    - "rainbow": that 10-color "kleinpanic" style gradient
#    - "custom": define your own 256-color sequence, etc.
# ---------------------------------------------------------------------------

KLEINPANIC_RAINBOW = [203, 198, 199, 164, 129, 93, 63, 33, 39, 44]

COLOR_MODES = [
    "none",
    "grayscale",
    "rainbow",
    "custom"
]

# For grayscale color, we can do a quick mapping function
def grayscale_256_shade(pixel_value):
    """
    Given a pixel_value in [0..255], produce a 256-color code
    that matches a grayscale.
    """
    # 232..255 is the grayscale ramp in 256-color
    # but let's map 0..255 -> 232..255
    # each step is about 1.0 * 24 / 256
    # but let's do an integer approach
    index = int((pixel_value / 255.0) * 23)
    return 232 + index


# ---------------------------------------------------------------------------
# 3) A function to generate ASCII from an image
# ---------------------------------------------------------------------------

def image_to_ascii(
    img_path,
    char_set=" .:-=+*#%@",
    scale=0.5,
    color_mode="none"
):
    """
    1) Load the image via Pillow
    2) Resize according to `scale`
    3) Convert to grayscale
    4) Map each pixel to an ASCII char
    5) If color_mode != "none", wrap each char in ANSI color codes
    6) Return list of lines (strings)
    """

    try:
        img = Image.open(img_path)
    except Exception as e:
        raise ValueError(f"Could not open image '{img_path}': {e}")

    # Convert to RGB, then we'll make a grayscale
    img = img.convert("RGB")

    # Resize according to scale. Note that ASCII cells are "tall" in text, so we can
    # adjust the height less aggressively if we want correct aspect ratio.
    # Common technique: multiply width by some factor (~2) to account for character
    # aspect ratio. We'll do a simple approach here:
    w, h = img.size
    new_w = int(w * scale)
    # This is a hack to preserve aspect ratio for typical ASCII usage
    new_h = int(h * scale * 0.55)

    if new_w < 1: new_w = 1
    if new_h < 1: new_h = 1
    img = img.resize((new_w, new_h))

    # Convert each pixel to ASCII
    # We'll build lines in a list of strings
    ascii_lines = []

    # We'll keep a color_index if we do a rainbow
    color_index = 0

    # For each row
    for y in range(new_h):
        row_chars = []
        for x in range(new_w):
            r, g, b = img.getpixel((x, y))
            # Luminance approx
            gray = int(0.299*r + 0.587*g + 0.114*b)

            # Which char from the chosen set
            # scale the gray to the length of the char set
            char_idx = int((gray / 255) * (len(char_set) - 1))
            ascii_char = char_set[char_idx]

            if color_mode == "none":
                row_chars.append(ascii_char)
            elif color_mode == "grayscale":
                # Map pixel gray to an approximate grayscale 256 color code
                color_code = grayscale_256_shade(gray)
                row_chars.append(f"\x1b[38;5;{color_code}m{ascii_char}\x1b[0m")
            elif color_mode == "rainbow":
                # Use the KLEINPANIC_RAINBOW sequence in a cyc pattern
                c = KLEINPANIC_RAINBOW[color_index % len(KLEINPANIC_RAINBOW)]
                row_chars.append(f"\x1b[1;38;5;{c}m{ascii_char}\x1b[0m")
                color_index += 1
            elif color_mode == "custom":
                # For demonstration, let's just color by hue from the (r,g,b),
                # or do your own custom logic. We'll do a naive approach:
                # pick the highest of r,g,b and map that to a color range:
                # This is very naive; you can do something more advanced.
                top = max(r,g,b)
                if top == 0:
                    color_code = 16  # black
                else:
                    if top == r:
                        color_code = 196  # red
                    elif top == g:
                        color_code = 46   # green
                    else:
                        color_code = 21   # blue
                row_chars.append(f"\x1b[1;38;5;{color_code}m{ascii_char}\x1b[0m")

        ascii_lines.append("".join(row_chars))

    return ascii_lines


# ---------------------------------------------------------------------------
# 4) The "random-colors" table: show each code 0..255 in its own color
# ---------------------------------------------------------------------------

def display_ansi_color_table():
    """
    Print a table of 256 color codes to the terminal.
    """
    print("256-color ANSI escape codes demonstration:\n")
    for c in range(256):
        # We'll print the number, then the swatch
        # \x1b[48;5;{c}m => set background color
        # \x1b[38;5;{c}m => set foreground color
        # We'll do foreground for clarity
        sys.stdout.write(f"\x1b[38;5;{c}m {c:3d} \x1b[0m")
        # For nicer formatting, break lines every 8
        if (c + 1) % 8 == 0:
            sys.stdout.write("\n")
    print("\n\x1b[0m")


# ---------------------------------------------------------------------------
# 5) A simple curses-based TUI
#    - loads the image
#    - shows the ASCII
#    - press keys to adjust scale, cycle char sets, toggle color, etc.
# ---------------------------------------------------------------------------

def tui_main(stdscr, args):
    curses.curs_set(0)  # hide cursor
    stdscr.nodelay(False)

    # We'll keep track of user’s chosen:
    scale = args.scale
    char_index = 0
    color_mode_index = 0

    # Pre-load the image so we don’t open it repeatedly
    image_path = args.image
    # We'll do a small function that re-renders
    def render_ascii():
        try:
            lines = image_to_ascii(
                img_path=image_path,
                char_set=CHAR_SETS[char_index],
                scale=scale,
                color_mode=COLOR_MODES[color_mode_index]
            )
        except Exception as e:
            return [f"Error loading image: {e}"]

        return lines

    ascii_lines = render_ascii()

    while True:
        stdscr.clear()
        # Show instructions top line
        h, w = stdscr.getmaxyx()
        instructions = (
            "[UP/DOWN] Scale = %.2f  |  [LEFT/RIGHT] CharSet=%d  "
            "[C]olorMode=%s  [Q]uit"
            % (scale, char_index, COLOR_MODES[color_mode_index])
        )
        stdscr.addstr(0, 0, instructions)

        # Then show the ASCII lines
        for i, line in enumerate(ascii_lines[: h - 2]):
            # We have to strip out real ANSI codes if we want curses to show them as raw.
            # But we actually want to pass color codes to the real terminal, which curses
            # won't do natively unless we do addstr with some advanced method. For simplicity,
            # let's just addstr the raw with no colors. (But that defeats the color in curses.)
            #
            # **Alternatively**: We can "fake" it by removing codes and let curses handle color,
            # but that requires building curses color pairs. This is more complicated.
            #
            # For a "true" color TUI, you'd parse the lines for codes and set curses color
            # pairs. But that’s beyond a simple example. We'll do a simpler approach:
            # we push the actual ANSI escapes out. This requires halfdelay mode or cbreak,
            # and direct writes. Let's do a hack: we bypass curses for these lines:
            try:
                # move cursor
                stdscr.move(i+1, 0)
                # write raw to terminal
                # curses doesn't like unprintable chars, so we flush them directly
                sys.stdout.write(f"\x1b[{i+1};0H")  # move cursor in terminal
                sys.stdout.write(line + "\x1b[0m\n")
            except:
                pass

        stdscr.refresh()

        # Get user input
        c = stdscr.getch()
        if c == ord('q') or c == ord('Q'):
            break
        elif c == curses.KEY_UP:
            scale += 0.05
            ascii_lines = render_ascii()
        elif c == curses.KEY_DOWN:
            scale -= 0.05
            if scale < 0.01:
                scale = 0.01
            ascii_lines = render_ascii()
        elif c == curses.KEY_LEFT:
            char_index = (char_index - 1) % len(CHAR_SETS)
            ascii_lines = render_ascii()
        elif c == curses.KEY_RIGHT:
            char_index = (char_index + 1) % len(CHAR_SETS)
            ascii_lines = render_ascii()
        elif c in (ord('c'), ord('C')):
            color_mode_index = (color_mode_index + 1) % len(COLOR_MODES)
            ascii_lines = render_ascii()
        else:
            # ignore other keys
            pass


# ---------------------------------------------------------------------------
# 6) Main CLI entry point
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(
        description="ASCII Art Converter - with TUI and color options."
    )
    parser.add_argument("image", nargs="?", help="Path to input image (jpg/png/gif, etc.)")
    parser.add_argument("--scale", type=float, default=0.5, help="Scaling factor for ASCII (default=0.5)")
    parser.add_argument("--chars", type=str, default=None,
                        help="Custom ASCII characters to use (overrides built-ins)")
    parser.add_argument("--gradient", type=str, default=None, choices=COLOR_MODES,
                        help="Which color mode to use? none/grayscale/rainbow/custom")
    parser.add_argument("--no-tui", action="store_true", help="Disable TUI; just print ASCII once.")
    parser.add_argument("--random-colors", action="store_true",
                        help="Show a table of 256 ANSI color codes, then exit.")
    args = parser.parse_args()

    # 1) If user wants the color table, show it, then exit
    if args.random_colors:
        display_ansi_color_table()
        sys.exit(0)

    # 2) If no image path is given, either show usage or exit
    if not args.image:
        print("No image specified. Use '--random-colors' or provide an image file.\n")
        parser.print_help()
        sys.exit(1)

    if not os.path.exists(args.image):
        print(f"ERROR: Image file not found: {args.image}")
        sys.exit(1)

    # 3) If user gave a custom chars, prepend that to CHAR_SETS or replace the first set
    if args.chars is not None:
        CHAR_SETS[0] = args.chars

    # 4) If user gave a gradient
    if args.gradient is not None:
        # We'll set that as the first color mode
        # or just override a default index. Let's do a quick approach:
        if args.gradient in COLOR_MODES:
            # Move that gradient to the front
            # or set the default to that
            # For the TUI to start in that gradient, you'd do:
            # Not strictly required if using no-tui, but let's do it anyway:
            pass
        else:
            print(f"Unknown --gradient {args.gradient}, must be in {COLOR_MODES}")
            sys.exit(1)

    # 5) If user does not want TUI, we just do a single conversion
    #    and print to stdout
    if args.no_tui:
        color_mode = args.gradient if args.gradient else "none"
        chars = args.chars if args.chars else CHAR_SETS[0]
        lines = image_to_ascii(
            img_path=args.image,
            char_set=chars,
            scale=args.scale,
            color_mode=color_mode
        )
        for ln in lines:
            print(ln)
        sys.exit(0)

    # 6) Otherwise, run the curses TUI
    #    We pass all arguments so the TUI can use them
    try:
        curses.wrapper(tui_main, args)
    except KeyboardInterrupt:
        pass


if __name__ == "__main__":
    main()

